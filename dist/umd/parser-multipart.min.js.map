{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/parseHeader.ts","../../node_modules/newline-iterator/dist/esm/index.mjs","../../node_modules/index-of-newline/dist/esm/index.mjs","../../src/lib/parseText.ts","../../src/lib/parseStatus.ts","../../src/ResponseParser.ts","../../src/PartParser.ts","../../src/MultipartParser.ts"],"sourcesContent":["// @ts-ignore\nimport { HeadersObject } from '../index.ts';\n\nexport default function parseHeader(result: HeadersObject, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","import indexOfNewline from 'index-of-newline';\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.iterator;\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */ export default function newlineIterator(string) {\n    let offset = 0;\n    const iterator = {\n        next () {\n            if (offset >= string.length) return {\n                value: undefined,\n                done: true\n            };\n            const args = indexOfNewline(string, offset, true);\n            let index = args[0];\n            let skip = args[1];\n            if (index < 0) {\n                index = string.length;\n                skip = 0;\n            }\n            const line = string.substr(offset, index - offset);\n            offset = index + skip;\n            return {\n                value: line,\n                done: false\n            };\n        }\n    };\n    if (hasIterator) {\n        iterator[Symbol.iterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n};\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */ export default function indexOfNewline(string, offset = 0, includeLength = false) {\n    if (offset < 0) throw new Error('Unexpected negative offset');\n    if (offset > string.length) throw new Error(`Offset is longer than the string. Offset: ${offset}. String: ${string.length}`);\n    while(offset < string.length){\n        const value = string[offset];\n        if (value === '\\n') return includeLength ? [\n            offset,\n            1\n        ] : offset;\n        else if (value === '\\r') {\n            return includeLength ? [\n                offset,\n                string[offset + 1] === '\\n' ? 2 : 1\n            ] : offset;\n        }\n        offset++;\n    }\n    return includeLength ? [\n        -1,\n        0\n    ] : -1;\n};\n","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n  };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { Version, HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return JSON.parse(this.body);\n  }\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport MultipartResponse from './ResponseParser.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: HeadersObject = {};\n  response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this.response.done()) this.response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this.response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this.response.push(line);\n    }\n  }\n}\n","// @ts-ignore\nimport Part from './PartParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"names":["parseHeader","result","line","delimiter","index","indexOf","Error","concat","key","slice","value","trim","toLowerCase","hasIterator","Symbol","iterator","newlineIterator","string","offset","next","length","undefined","done","args","arguments","includeLength","indexOfNewline","skip","substr","this","parseText","parser","text","push","ParseStatus","statusLine","_classCallCheck","instance","Constructor","Headers","Body","BodyHeaders","headers","MultipartResponse","contentType","body","_parsingState","status","lines","prototype","parse","join","match","version","major","parseInt","minor","statusText","ok","parseStatus","json","JSON","Response","MultipartPart","response","Parts","MultipartParser","parts","boundaryEnd","boundary","get","split","type","shift","forEach","part","_this","Part"],"mappings":"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"}