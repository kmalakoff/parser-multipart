{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/HeadersPolyfill.ts","../../src/ResponseParsed.ts","../../src/lib/BodyHeaders.ts","../../src/lib/parseHeader.ts","../../src/lib/parseStatus.ts","../../node_modules/newline-iterator/dist/esm/index.mjs","../../src/ResponseParser.ts","../../node_modules/index-of-newline/dist/esm/index.mjs","../../src/lib/parseText.ts","../../src/PartParser.ts","../../src/MultipartParser.ts"],"sourcesContent":["class HeadersPolyfill implements Headers {\n  headers: Record<string, string>;\n\n  constructor(headers) {\n    this.headers = headers;\n  }\n  get(key) {\n    return this.headers[key];\n  }\n  set(key, value) {\n    this.headers[key] = value;\n  }\n  append(key, value) {\n    this.headers[key] = value;\n  }\n  delete(key) {\n    delete this.headers[key];\n  }\n  has(key) {\n    return this.headers[key] === undefined;\n  }\n  forEach(fn) {\n    for (var key in this.headers) fn(this.headers[key]);\n  }\n  getSetCookie(): string[] {\n    throw new Error('Unsupported: getSetCookie');\n  }\n}\n\nexport default typeof Headers === 'undefined' ? HeadersPolyfill : Headers;\n","// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.js';\n// @ts-ignore\nimport HeadersPolyfill from './lib/HeadersPolyfill.ts';\n\nexport interface Parser {\n  headers: BodyHeaders;\n  body: string;\n}\n\nexport default class ParsedResponse implements Response {\n  private _parser: Parser;\n  private _bodyUsed: boolean;\n\n  constructor(parser: Parser) {\n    this._parser = parser;\n    this._bodyUsed = false;\n  }\n\n  get type(): ResponseType {\n    return 'default';\n  }\n  get headers() {\n    return new HeadersPolyfill(this._parser.headers.headers as unknown as Record<string, string>);\n  }\n\n  get body(): ReadableStream<Uint8Array> {\n    throw new Error('Not supported: body');\n  }\n\n  get ok() {\n    return this._parser.headers.ok;\n  }\n  get status() {\n    return this._parser.headers.status;\n  }\n  get statusText() {\n    return this._parser.headers.statusText;\n  }\n  get redirected() {\n    return false;\n  }\n  get url() {\n    return '';\n  }\n  clone() {\n    return new ParsedResponse(this._parser);\n  }\n  get bodyUsed() {\n    return this._bodyUsed;\n  }\n\n  text(): Promise<string> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(this._parser.body);\n  }\n\n  json(): Promise<unknown> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(JSON.parse(this._parser.body));\n  }\n\n  arrayBuffer(): Promise<ArrayBuffer> {\n    throw new Error('Unsupported: arrayBuffer');\n  }\n\n  blob(): Promise<Blob> {\n    throw new Error('Unsupported: blob');\n  }\n\n  formData(): Promise<FormData> {\n    throw new Error('Unsupported: formData');\n  }\n}\n","// @ts-ignore\nimport type { Version } from './types.ts';\n\nexport default class BodyHeaders {\n  version: Version;\n  headers: Record<string, string> = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n","export default function parseHeader(result: Record<string, string>, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n  };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","import indexOfNewline from 'index-of-newline';\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.iterator;\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */ export default function newlineIterator(string) {\n    let offset = 0;\n    const iterator = {\n        next () {\n            if (offset >= string.length) return {\n                value: undefined,\n                done: true\n            };\n            const args = indexOfNewline(string, offset, true);\n            let index = args[0];\n            let skip = args[1];\n            if (index < 0) {\n                index = string.length;\n                skip = 0;\n            }\n            const line = string.substr(offset, index - offset);\n            offset = index + skip;\n            return {\n                value: line,\n                done: false\n            };\n        }\n    };\n    if (hasIterator) {\n        iterator[Symbol.iterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n};\n","// @ts-ignore\nimport ResponseParsed from './ResponseParsed.ts';\n// @ts-ignore\nimport type { Parser } from './ResponseParsed.ts';\n// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return new ResponseParsed(this as Parser);\n  }\n}\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */ export default function indexOfNewline(string, offset = 0, includeLength = false) {\n    if (offset < 0) throw new Error('Unexpected negative offset');\n    if (offset > string.length) throw new Error(`Offset is longer than the string. Offset: ${offset}. String: ${string.length}`);\n    while(offset < string.length){\n        const value = string[offset];\n        if (value === '\\n') return includeLength ? [\n            offset,\n            1\n        ] : offset;\n        else if (value === '\\r') {\n            return includeLength ? [\n                offset,\n                string[offset + 1] === '\\n' ? 2 : 1\n            ] : offset;\n        }\n        offset++;\n    }\n    return includeLength ? [\n        -1,\n        0\n    ] : -1;\n};\n","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport MultipartResponse from './ResponseParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: Record<string, string> = {};\n  _response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this._response.done()) this._response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this._response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this._response.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete part');\n    return this._response.response;\n  }\n}\n","// @ts-ignore\nimport Part from './PartParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: Record<string, string> = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | Record<string, string>) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as Record<string, string>)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): MultipartParser {\n    parseText(this, text);\n    return this;\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n\n  get responses(): Response[] {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete parser');\n    return this.parts.map((part) => part.response);\n  }\n}\n"],"names":["HeadersPolyfill$1","Headers","HeadersPolyfill","headers","instance","Constructor","this","prototype","get","key","set","value","append","delete","has","undefined","forEach","fn","getSetCookie","Error","ParsedResponse","parser","_parser","_bodyUsed","clone","text","Promise","resolve","body","json","JSON","parse","arrayBuffer","blob","formData","type","ok","status","statusText","redirected","url","bodyUsed","BodyHeaders","parseHeader","result","line","delimiter","index","indexOf","concat","slice","trim","toLowerCase","statusLine","ParseStatus","hasIterator","Symbol","iterator","newlineIterator","string","offset","next","length","done","args","arguments","includeLength","indexOfNewline","skip","substr","parseText","push","Body","MultipartResponse","contentType","_parsingState","lines","join","match","version","major","parseInt","minor","parseStatus","response","ResponseParsed","Response","MultipartPart","_response","Parts","MultipartParser","parts","boundaryEnd","boundary","split","shift","part","_this","Part","responses","map"],"mappings":"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"}