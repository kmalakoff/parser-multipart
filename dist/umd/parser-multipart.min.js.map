{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/parseHeader.ts","../../node_modules/newline-iterator/dist/esm/index.mjs","../../node_modules/index-of-newline/dist/esm/index.mjs","../../src/lib/parseText.ts","../../src/lib/parseStatus.ts","../../src/Response.ts","../../src/Part.ts","../../src/Parser.ts"],"sourcesContent":["// @ts-ignore\nimport { HeadersObject } from '../index.ts';\n\nexport default function parseHeader(result: HeadersObject, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nimport indexOfNewline from \"index-of-newline\";\nvar hasIterator = typeof Symbol !== \"undefined\" && Symbol.iterator;\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */ export default function newlineIterator(string) {\n    var offset = 0;\n    var iterator = {\n        next: function next() {\n            if (offset >= string.length) return {\n                value: undefined,\n                done: true\n            };\n            var ref = _slicedToArray(indexOfNewline(string, offset, true), 2), index = ref[0], skip = ref[1];\n            if (index < 0) {\n                index = string.length;\n                skip = 0;\n            }\n            var line = string.substr(offset, index - offset);\n            offset = index + skip;\n            return {\n                value: line,\n                done: false\n            };\n        }\n    };\n    if (hasIterator) {\n        iterator[Symbol.iterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n};\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */ export default function indexOfNewline(string) {\n    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, includeLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    if (offset < 0) throw new Error(\"Unexpected negative offset\");\n    if (offset > string.length) throw new Error(\"Offset is longer than the string. Offset: \".concat(offset, \". String: \").concat(string.length));\n    while(offset < string.length){\n        var value = string[offset];\n        if (value === \"\\n\") return includeLength ? [\n            offset,\n            1\n        ] : offset;\n        else if (value === \"\\r\") {\n            return includeLength ? [\n                offset,\n                string[offset + 1] === \"\\n\" ? 2 : 1\n            ] : offset;\n        }\n        offset++;\n    }\n    return includeLength ? [\n        -1,\n        0\n    ] : -1;\n};\n","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { Version, HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return JSON.parse(this.body);\n  }\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport MultipartResponse from './Response.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: HeadersObject = {};\n  response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this.response.done()) this.response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this.response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this.response.push(line);\n    }\n  }\n}\n","// @ts-ignore\nimport Part from './Part.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"names":["parseHeader","result","line","delimiter","index","indexOf","Error","concat","key","slice","value","trim","toLowerCase","_arrayLikeToArray","arr","len","length","i","arr2","Array","_slicedToArray","isArray","_arrayWithHoles","_i","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","push","err","_iterableToArrayLimit","o","minLen","n","Object","prototype","toString","constructor","name","from","test","_unsupportedIterableToArray","TypeError","_nonIterableRest","hasIterator","newlineIterator","string","offset","undefined","ref","arguments","includeLength","indexOfNewline","skip","substr","this","parseText","parser","text","ParseStatus","statusLine","_classCallCheck","instance","Constructor","Headers","Body","BodyHeaders","headers","MultipartResponse","contentType","body","_parsingState","status","lines","parse","join","match","version","major","parseInt","minor","statusText","ok","parseStatus","json","JSON","Response","MultipartPart","response","Parts","MultipartParser","parts","boundaryEnd","boundary","get","split","type","shift","forEach","part","_this","Part"],"mappings":"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"}