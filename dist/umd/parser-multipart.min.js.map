{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/HeadersPolyfill.ts","../../src/ResponseParsed.ts","../../src/lib/BodyHeaders.ts","../../src/lib/parseHeader.ts","../../src/lib/parseStatus.ts","../../src/lib/parseText.ts","../../src/ResponseParser.ts","../../src/PartParser.ts","../../src/MultipartParser.ts"],"sourcesContent":["class HeadersPolyfill implements Headers {\n  headers: Record<string, string>;\n\n  constructor(headers) {\n    this.headers = headers;\n  }\n  get(key) {\n    return this.headers[key];\n  }\n  set(key, value) {\n    this.headers[key] = value;\n  }\n  append(key, value) {\n    this.headers[key] = value;\n  }\n  delete(key) {\n    delete this.headers[key];\n  }\n  has(key) {\n    return this.headers[key] === undefined;\n  }\n  forEach(fn) {\n    for (const key in this.headers) fn(this.headers[key]);\n  }\n  getSetCookie(): string[] {\n    throw new Error('Unsupported: getSetCookie');\n  }\n}\n\nexport default typeof Headers === 'undefined' ? HeadersPolyfill : Headers;\n","// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.js';\n// @ts-ignore\nimport HeadersPolyfill from './lib/HeadersPolyfill.ts';\n\nexport interface Parser {\n  headers: BodyHeaders;\n  body: string;\n}\n\nexport default class ParsedResponse implements Response {\n  private _parser: Parser;\n  private _bodyUsed: boolean;\n\n  constructor(parser: Parser) {\n    this._parser = parser;\n    this._bodyUsed = false;\n  }\n\n  get type(): ResponseType {\n    return 'default';\n  }\n  get headers() {\n    return new HeadersPolyfill(this._parser.headers.headers as unknown as Record<string, string>);\n  }\n\n  get body(): ReadableStream<Uint8Array> {\n    throw new Error('Not supported: body');\n  }\n\n  get ok() {\n    return this._parser.headers.ok;\n  }\n  get status() {\n    return this._parser.headers.status;\n  }\n  get statusText() {\n    return this._parser.headers.statusText;\n  }\n  get redirected() {\n    return false;\n  }\n  get url() {\n    return '';\n  }\n  clone() {\n    return new ParsedResponse(this._parser);\n  }\n  get bodyUsed() {\n    return this._bodyUsed;\n  }\n\n  text(): Promise<string> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(this._parser.body);\n  }\n\n  json(): Promise<unknown> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(JSON.parse(this._parser.body));\n  }\n\n  arrayBuffer(): Promise<ArrayBuffer> {\n    throw new Error('Unsupported: arrayBuffer');\n  }\n\n  blob(): Promise<Blob> {\n    throw new Error('Unsupported: blob');\n  }\n\n  formData(): Promise<FormData> {\n    throw new Error('Unsupported: formData');\n  }\n}\n","// @ts-ignore\nimport type { Version } from './types.ts';\n\nexport default class BodyHeaders {\n  version: Version;\n  headers: Record<string, string> = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n","export default function parseHeader(result: Record<string, string>, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n  };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport ResponseParsed from './ResponseParsed.ts';\n// @ts-ignore\nimport type { Parser } from './ResponseParsed.ts';\n// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return new ResponseParsed(this as Parser);\n  }\n}\n","// @ts-ignore\nimport MultipartResponse from './ResponseParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: Record<string, string> = {};\n  _response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this._response.done()) this._response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this._response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this._response.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete part');\n    return this._response.response;\n  }\n}\n","// @ts-ignore\nimport Part from './PartParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: Record<string, string> = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | Record<string, string>) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as Record<string, string>)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): MultipartParser {\n    parseText(this, text);\n    return this;\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n\n  get responses(): Response[] {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete parser');\n    return this.parts.map((part) => part.response);\n  }\n}\n"],"names":["HeadersPolyfill$1","Headers","HeadersPolyfill","headers","this","get","key","set","value","append","delete","has","undefined","forEach","fn","getSetCookie","Error","ParsedResponse","parser","_define_property","_parser","_bodyUsed","type","body","ok","status","statusText","redirected","url","clone","bodyUsed","text","Promise","resolve","json","JSON","parse","arrayBuffer","blob","formData","BodyHeaders","version","parseHeader","result","line","delimiter","index","indexOf","concat","slice","trim","toLowerCase","statusLine","parseText","iterator","newlineIterator","next","done","push","ParseStatus","MultipartResponse","contentType","_parsingState","lines","join","length","match","major","parseInt","minor","parseStatus","response","ResponseParsed","MultipartPart","_response","MultipartParser","parts","boundaryEnd","boundary","split","shift","part","_this","Part","responses","map"],"mappings":"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"}