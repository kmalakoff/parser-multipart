{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/parseHeader.ts","../../src/lib/parseText.ts","../../src/lib/parseStatus.ts","../../src/Response.ts","../../src/Part.ts","../../src/Parser.ts"],"sourcesContent":["import { HeadersObject } from \"../index\";\n\nexport default function parseHeader(result: HeadersObject, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","import newlineIterator from \"newline-iterator\";\nimport { IParser } from \"../index\";\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","import { Version } from \"../index\";\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.js\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === \"OK\";\n  return true;\n}\n","import parseHeader from \"./lib/parseHeader.js\";\nimport parseStatus from \"./lib/parseStatus.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { Version, HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport default class MultipartResponse {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n  body: string = null;\n\n  // bodyUsed: boolean;\n  // redirected: boolean;\n  // trailer: Promise<Headers>;\n  // type: ResponseType;\n  // url: string;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n    lines: [],\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed response\");\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error(\"Unexpected parsing state\");\n      this.body = this._parsingState.lines.join(\"\\r\\n\");\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this, line)) parseHeader(this.headers, line, \":\");\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    if (this.headers[\"content-type\"].indexOf(\"application/json\") === -1) {\n      throw new Error(`Not json response. Content type: ${this.headers[\"content-type\"]}`);\n    }\n    return JSON.parse(this.body);\n  }\n}\n","import parseHeader from \"./lib/parseHeader.js\";\nimport parseText from \"./lib/parseText.js\";\nimport MultipartResponse from \"./Response.js\";\nimport type { HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: HeadersObject = {};\n  response: MultipartResponse = new MultipartResponse();\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed part\");\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error(\"Unexpected parsing state\");\n      if (!this.response.done()) this.response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers[\"content-type\"] !== \"application/http\")\n          throw new Error(`Unexpected content type: ${this.headers[\"content-type\"]}`);\n        this._parsingState.status = ParseStatus.Response;\n      } else parseHeader(this.headers, line, \":\");\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this.response.push(line);\n    }\n  }\n}\n","import Part from \"./Part.js\";\nimport parseHeader from \"./lib/parseHeader.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error(\"Headers missing\");\n\n    let contentType: string;\n    if (typeof headers === \"string\") contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get(\"content-type\");\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)[\"content-type\"];\n    if (!contentType) throw Error(\"content-type header not found\");\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf(\"multipart\") !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    for (const part of parts) parseHeader(this.headers, part, \"=\");\n\n    // boundary\n    if (!this.headers.boundary) throw new Error(\"Invalid Content Type: no boundary\");\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed multipart\");\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"names":["parseHeader","result","line","delimiter","index","indexOf","Error","key","slice","value","trim","toLowerCase","parseText","parser","text","iterator","newlineIterator","next","done","push","ParseStatus","statusLine","MultipartResponse","status","Headers","lines","this","_parsingState","Body","body","join","length","match","version","major","parseInt","minor","statusText","ok","parseStatus","headers","JSON","parse","MultipartPart","Response","response","MultipartParser","Parts","boundaryEnd","contentType","get","parts","split","type","shift","part","boundary","Part"],"mappings":"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"}