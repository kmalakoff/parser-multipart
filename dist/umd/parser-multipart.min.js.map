{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/parseHeader.ts","../../node_modules/newline-iterator/dist/esm/index.mjs","../../node_modules/index-of-newline/dist/esm/index.js","../../src/lib/parseText.ts","../../src/lib/parseStatus.ts","../../src/Response.ts","../../src/Part.ts","../../src/Parser.ts"],"sourcesContent":["// @ts-ignore\nimport { HeadersObject } from '../index.ts';\n\nexport default function parseHeader(result: HeadersObject, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","import indexOfNewline from 'index-of-newline';\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.iterator;\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */ export default function newlineIterator(string) {\n    let offset = 0;\n    const iterator = {\n        next () {\n            if (offset >= string.length) return {\n                value: undefined,\n                done: true\n            };\n            let [index, skip] = indexOfNewline(string, offset, true);\n            if (index < 0) {\n                index = string.length;\n                skip = 0;\n            }\n            const line = string.substr(offset, index - offset);\n            offset = index + skip;\n            return {\n                value: line,\n                done: false\n            };\n        }\n    };\n    if (hasIterator) {\n        iterator[Symbol.iterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n};\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */\nexport default function indexOfNewline(string, offset = 0, includeLength = false) {\n  if (offset < 0) throw new Error(\"Unexpected negative offset\");\n  if (offset > string.length) throw new Error(`Offset is longer than the string. Offset: ${offset}. String: ${string.length}`);\n\n  while (offset < string.length) {\n    const value = string[offset];\n    if (value === \"\\n\") return includeLength ? [offset, 1] : offset;else if (value === \"\\r\") {\n      return includeLength ? [offset, string[offset + 1] === \"\\n\" ? 2 : 1] : offset;\n    }\n    offset++;\n  }\n\n  return includeLength ? [-1, 0] : -1;\n}\n//# sourceMappingURL=index.js.map","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { Version, HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return JSON.parse(this.body);\n  }\n}\n","// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport MultipartResponse from './Response.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: HeadersObject = {};\n  response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this.response.done()) this.response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this.response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this.response.push(line);\n    }\n  }\n}\n","// @ts-ignore\nimport Part from './Part.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n// @ts-ignore\nimport type { HeadersObject } from './index.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"names":["parseHeader","result","line","delimiter","index","indexOf","Error","concat","key","slice","value","trim","toLowerCase","_arrayLikeToArray","arr","len","hasIterator","Symbol","iterator","newlineIterator","string","offset","next","length","undefined","done","indexOfNewline","arguments","includeLength","skip","substr","this","parseText","parser","text","push","ParseStatus","statusLine","_classCallCheck","instance","Constructor","Headers","Body","BodyHeaders","headers","MultipartResponse","contentType","body","_parsingState","status","lines","prototype","parse","join","match","version","major","parseInt","minor","statusText","ok","parseStatus","json","JSON","Response","MultipartPart","response","Parts","MultipartParser","parts","boundaryEnd","boundary","get","split","type","shift","forEach","part","_this","Part"],"mappings":"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"}