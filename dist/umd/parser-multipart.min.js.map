{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/parseHeader.ts","../../src/lib/parseText.ts","../../src/lib/parseStatus.ts","../../src/Response.ts","../../src/Part.ts","../../src/Parser.ts"],"sourcesContent":["import { HeadersObject } from \"../index\";\n\nexport default function parseHeader(result: HeadersObject, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","import newlineIterator from \"newline-iterator\";\nimport { IParser } from \"../index\";\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","import { Version } from \"../index\";\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.js\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === \"OK\";\n  return true;\n}\n","import parseHeader from \"./lib/parseHeader.js\";\nimport parseStatus from \"./lib/parseStatus.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { Version, HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error(\"Response missing a content type\");\n    this.contentType = contentType;\n    if (this.contentType === \"application/http\") {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed response\");\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error(\"Unexpected parsing state\");\n      this.body = this._parsingState.lines.join(\"\\r\\n\");\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, \":\");\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    return JSON.parse(this.body);\n  }\n}\n","import parseHeader from \"./lib/parseHeader.js\";\nimport parseText from \"./lib/parseText.js\";\nimport MultipartResponse from \"./Response.js\";\nimport type { HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: HeadersObject = {};\n  response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed part\");\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error(\"Unexpected parsing state\");\n      if (!this.response.done()) this.response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers[\"content-type\"] === undefined) throw new Error(\"Missing content type\");\n        this._parsingState.status = ParseStatus.Response;\n        this.response = new MultipartResponse(this.headers[\"content-type\"]);\n      } else parseHeader(this.headers, line, \":\");\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this.response.push(line);\n    }\n  }\n}\n","import Part from \"./Part.js\";\nimport parseHeader from \"./lib/parseHeader.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error(\"Headers missing\");\n\n    let contentType: string;\n    if (typeof headers === \"string\") contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get(\"content-type\");\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)[\"content-type\"];\n    if (!contentType) throw Error(\"content-type header not found\");\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf(\"multipart\") !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    for (const part of parts) parseHeader(this.headers, part, \"=\");\n\n    // boundary\n    if (!this.headers.boundary) throw new Error(\"Invalid Content Type: no boundary\");\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed multipart\");\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"names":["parseHeader","result","line","delimiter","index","indexOf","Error","key","slice","value","trim","toLowerCase","parseText","parser","text","iterator","newlineIterator","next","done","push","ParseStatus","statusLine","BodyHeaders","MultipartResponse","contentType","status","Body","lines","undefined","this","headers","_parsingState","Headers","body","join","length","match","version","major","parseInt","minor","statusText","ok","parseStatus","JSON","parse","MultipartPart","Response","response","MultipartParser","Parts","boundaryEnd","get","parts","split","type","shift","part","boundary","Part"],"mappings":"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"}