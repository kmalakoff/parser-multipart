{"version":3,"file":"parser-multipart.min.js","sources":["../../src/lib/HeadersPolyfill.ts","../../src/ResponseParsed.ts","../../src/lib/BodyHeaders.ts","../../src/lib/parseHeader.ts","../../src/lib/parseStatus.ts","../../node_modules/newline-iterator/dist/esm/index.mjs","../../node_modules/index-of-newline/dist/esm/index.mjs","../../src/lib/parseText.ts","../../src/ResponseParser.ts","../../src/PartParser.ts","../../src/MultipartParser.ts"],"sourcesContent":["class HeadersPolyfill implements Headers {\n  headers: Record<string, string>;\n\n  constructor(headers) {\n    this.headers = headers;\n  }\n  get(key) {\n    return this.headers[key];\n  }\n  set(key, value) {\n    this.headers[key] = value;\n  }\n  append(key, value) {\n    this.headers[key] = value;\n  }\n  delete(key) {\n    delete this.headers[key];\n  }\n  has(key) {\n    return this.headers[key] === undefined;\n  }\n  forEach(fn) {\n    for (const key in this.headers) fn(this.headers[key]);\n  }\n  getSetCookie(): string[] {\n    throw new Error('Unsupported: getSetCookie');\n  }\n}\n\nexport default typeof Headers === 'undefined' ? HeadersPolyfill : Headers;\n","// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.js';\n// @ts-ignore\nimport HeadersPolyfill from './lib/HeadersPolyfill.ts';\n\nexport interface Parser {\n  headers: BodyHeaders;\n  body: string;\n}\n\nexport default class ParsedResponse implements Response {\n  private _parser: Parser;\n  private _bodyUsed: boolean;\n\n  constructor(parser: Parser) {\n    this._parser = parser;\n    this._bodyUsed = false;\n  }\n\n  get type(): ResponseType {\n    return 'default';\n  }\n  get headers() {\n    return new HeadersPolyfill(this._parser.headers.headers as unknown as Record<string, string>);\n  }\n\n  get body(): ReadableStream<Uint8Array> {\n    throw new Error('Not supported: body');\n  }\n\n  get ok() {\n    return this._parser.headers.ok;\n  }\n  get status() {\n    return this._parser.headers.status;\n  }\n  get statusText() {\n    return this._parser.headers.statusText;\n  }\n  get redirected() {\n    return false;\n  }\n  get url() {\n    return '';\n  }\n  clone() {\n    return new ParsedResponse(this._parser);\n  }\n  get bodyUsed() {\n    return this._bodyUsed;\n  }\n\n  text(): Promise<string> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(this._parser.body);\n  }\n\n  json(): Promise<unknown> {\n    if (this._bodyUsed) throw new Error('Body already consumed');\n    this._bodyUsed = true;\n    return Promise.resolve(JSON.parse(this._parser.body));\n  }\n\n  arrayBuffer(): Promise<ArrayBuffer> {\n    throw new Error('Unsupported: arrayBuffer');\n  }\n\n  blob(): Promise<Blob> {\n    throw new Error('Unsupported: blob');\n  }\n\n  formData(): Promise<FormData> {\n    throw new Error('Unsupported: formData');\n  }\n}\n","// @ts-ignore\nimport type { Version } from './types.ts';\n\nexport default class BodyHeaders {\n  version: Version;\n  headers: Record<string, string> = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n","export default function parseHeader(result: Record<string, string>, line: string, delimiter: string): void {\n  const index = line.indexOf(delimiter);\n  if (index === -1) throw new Error(`Unexpected header format: ${line}`);\n  const key = line.slice(0, index);\n  const value = line.slice(index + 1);\n  result[key.trim().toLowerCase()] = value.trim();\n}\n","// @ts-ignore\nimport { Version } from '../index.ts';\n\nexport interface StatusResult {\n  version: Version;\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\n// https://github.com/watson/http-headers/blob/master/index.ts\nconst statusLine = /^[A-Z]+\\/(\\d)\\.(\\d) (\\d{3}) (.*)$/;\n\nexport default function parseStatus(result: StatusResult, line: string): boolean {\n  const match = line.match(statusLine);\n  if (!match) return false;\n\n  result.version = {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n  };\n  result.status = parseInt(match[3], 10);\n  result.statusText = match[4];\n  result.ok = result.statusText === 'OK';\n  return true;\n}\n","import indexOfNewline from 'index-of-newline';\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.iterator;\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */ export default function newlineIterator(string) {\n    let offset = 0;\n    const iterator = {\n        next () {\n            if (offset >= string.length) return {\n                value: undefined,\n                done: true\n            };\n            const args = indexOfNewline(string, offset, true);\n            let index = args[0];\n            let skip = args[1];\n            if (index < 0) {\n                index = string.length;\n                skip = 0;\n            }\n            const line = string.substr(offset, index - offset);\n            offset = index + skip;\n            return {\n                value: line,\n                done: false\n            };\n        }\n    };\n    if (hasIterator) {\n        iterator[Symbol.iterator] = function() {\n            return this;\n        };\n    }\n    return iterator;\n};\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */ export default function indexOfNewline(string, offset = 0, includeLength = false) {\n    if (offset < 0) throw new Error('Unexpected negative offset');\n    if (offset > string.length) throw new Error(`Offset is longer than the string. Offset: ${offset}. String: ${string.length}`);\n    while(offset < string.length){\n        const value = string[offset];\n        if (value === '\\n') return includeLength ? [\n            offset,\n            1\n        ] : offset;\n        else if (value === '\\r') {\n            return includeLength ? [\n                offset,\n                string[offset + 1] === '\\n' ? 2 : 1\n            ] : offset;\n        }\n        offset++;\n    }\n    return includeLength ? [\n        -1,\n        0\n    ] : -1;\n};\n","import newlineIterator from 'newline-iterator';\n// @ts-ignore\nimport { IParser } from '../index.ts';\n\nexport default function parseText(parser: IParser, text: string): void {\n  const iterator = newlineIterator(text);\n  let next = iterator.next();\n  while (!next.done) {\n    parser.push(next.value);\n    next = iterator.next();\n  }\n  if (!parser.done()) parser.push(null);\n}\n","// @ts-ignore\nimport ResponseParsed from './ResponseParsed.ts';\n// @ts-ignore\nimport type { Parser } from './ResponseParsed.ts';\n// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return new ResponseParsed(this as Parser);\n  }\n}\n","// @ts-ignore\nimport MultipartResponse from './ResponseParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Response = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n}\n\nexport default class MultipartPart {\n  headers: Record<string, string> = {};\n  _response: MultipartResponse | null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Headers,\n  };\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed part');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Response) throw new Error('Unexpected parsing state');\n      if (!this._response.done()) this._response.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) {\n        if (this.headers['content-type'] === undefined) throw new Error('Missing content type');\n        this._parsingState.status = ParseStatus.Response;\n        this._response = new MultipartResponse(this.headers['content-type']);\n      } else parseHeader(this.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Response) {\n      this._response.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete part');\n    return this._response.response;\n  }\n}\n","// @ts-ignore\nimport Part from './PartParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: Record<string, string> = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | Record<string, string>) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as Record<string, string>)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): MultipartParser {\n    parseText(this, text);\n    return this;\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n\n  get responses(): Response[] {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete parser');\n    return this.parts.map((part) => part.response);\n  }\n}\n"],"names":["HeadersPolyfill$1","Headers","HeadersPolyfill","headers","this","get","key","set","value","append","delete","has","undefined","forEach","fn","getSetCookie","Error","ParsedResponse","parser","_define_property","_parser","_bodyUsed","type","body","ok","status","statusText","redirected","url","clone","bodyUsed","text","Promise","resolve","json","JSON","parse","arrayBuffer","blob","formData","BodyHeaders","version","parseHeader","result","line","delimiter","index","indexOf","concat","slice","trim","toLowerCase","statusLine","hasIterator","Symbol","iterator","newlineIterator","string","offset","next","length","done","args","includeLength","arguments","indexOfNewline","skip","substr","parseText","push","ParseStatus","MultipartResponse","contentType","_parsingState","lines","join","match","major","parseInt","minor","parseStatus","response","ResponseParsed","MultipartPart","_response","MultipartParser","parts","boundaryEnd","boundary","split","shift","part","_this","Part","responses","map"],"mappings":"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"}