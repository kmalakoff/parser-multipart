{"version":3,"sources":["../../src/Parser.ts"],"names":["Part","parseHeader","parseText","ParseStatus","MultipartParser","constructor","headers","status","Parts","boundaryEnd","Error","contentType","get","parts","split","type","shift","trim","indexOf","part","boundary","_parsingState","done","parse","text","push","line","length"],"mappings":"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","sourcesContent":["import Part from \"./Part.js\";\nimport parseHeader from \"./lib/parseHeader.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error(\"Headers missing\");\n\n    let contentType: string;\n    if (typeof headers === \"string\") contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get(\"content-type\");\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)[\"content-type\"];\n    if (!contentType) throw Error(\"content-type header not found\");\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf(\"multipart\") !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    for (const part of parts) parseHeader(this.headers, part, \"=\");\n\n    // boundary\n    if (!this.headers.boundary) throw new Error(\"Invalid Content Type: no boundary\");\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed multipart\");\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n"],"file":"Parser.js"}