{"version":3,"sources":["../../src/Response.ts"],"names":["parseHeader","parseStatus","parseText","ParseStatus","BodyHeaders","MultipartResponse","constructor","contentType","status","Body","lines","undefined","Error","headers","_parsingState","Headers","done","parse","text","push","line","body","join","length","json","JSON"],"mappings":";;AAAA,OAAOA,WAAP,MAAwB,sBAAxB;AACA,OAAOC,WAAP,MAAwB,sBAAxB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AAGA,WAAYC,WAAZ;;WAAYA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;GAAAA,W,KAAAA,W;;AAUZ,OAAO,MAAMC,WAAN,CAAkB;AAAA;AAAA;;AAAA,qCAEE,EAFF;;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAQzB,eAAe,MAAMC,iBAAN,CAAwB;AAUrCC,EAAAA,WAAW,CAACC,WAAD,EAAsB;AAAA;;AAAA,qCARV,IAQU;;AAAA,kCAPlB,IAOkB;;AAAA,2CALY;AAC3CC,MAAAA,MAAM,EAAEL,WAAW,CAACM,IADuB;AAE3CC,MAAAA,KAAK,EAAE;AAFoC,KAKZ;;AAC/B,QAAIH,WAAW,KAAKI,SAApB,EAA+B,MAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AAC/B,SAAKL,WAAL,GAAmBA,WAAnB;;AACA,QAAI,KAAKA,WAAL,KAAqB,kBAAzB,EAA6C;AAC3C,WAAKM,OAAL,GAAe,IAAIT,WAAJ,EAAf;AACA,WAAKU,aAAL,CAAmBN,MAAnB,GAA4BL,WAAW,CAACY,OAAxC;AACD;AACF;;AAEDC,EAAAA,IAAI,GAAY;AACd,WAAO,CAAC,KAAKF,aAAb;AACD;;AAEDG,EAAAA,KAAK,CAACC,IAAD,EAAqB;AACxBhB,IAAAA,SAAS,CAAC,IAAD,EAAOgB,IAAP,CAAT;AACD;;AAEDC,EAAAA,IAAI,CAACC,IAAD,EAAqB;AACvB,QAAI,CAAC,KAAKN,aAAV,EAAyB,MAAM,IAAIF,KAAJ,CAAU,0CAAV,CAAN;;AACzB,QAAIQ,IAAI,KAAK,IAAb,EAAmB;AACjB,UAAI,KAAKN,aAAL,CAAmBN,MAAnB,KAA8BL,WAAW,CAACM,IAA9C,EAAoD,MAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;AACpD,WAAKS,IAAL,GAAY,KAAKP,aAAL,CAAmBJ,KAAnB,CAAyBY,IAAzB,CAA8B,MAA9B,CAAZ;AACA,WAAKR,aAAL,GAAqB,IAArB;AACA;AACD;;AAED,QAAI,KAAKA,aAAL,CAAmBN,MAAnB,KAA8BL,WAAW,CAACY,OAA9C,EAAuD;AACrD,UAAI,CAACK,IAAI,CAACG,MAAV,EAAkB,KAAKT,aAAL,CAAmBN,MAAnB,GAA4BL,WAAW,CAACM,IAAxC,CAAlB,KACK,IAAI,CAACR,WAAW,CAAC,KAAKY,OAAN,EAAeO,IAAf,CAAhB,EAAsCpB,WAAW,CAAC,KAAKa,OAAL,CAAaA,OAAd,EAAuBO,IAAvB,EAA6B,GAA7B,CAAX;AAC5C,KAHD,MAGO,IAAI,KAAKN,aAAL,CAAmBN,MAAnB,KAA8BL,WAAW,CAACM,IAA9C,EAAoD;AACzD,UAAI,CAACW,IAAI,CAACG,MAAV,EAAkB,KAAKJ,IAAL,CAAU,IAAV,EAAlB,KACK,KAAKL,aAAL,CAAmBJ,KAAnB,CAAyBS,IAAzB,CAA8BC,IAA9B;AACN;AACF;;AAEDF,EAAAA,IAAI,GAAW;AACb,QAAI,KAAKJ,aAAT,EAAwB,MAAM,IAAIF,KAAJ,CAAU,0CAAV,CAAN;AACxB,WAAO,KAAKS,IAAZ;AACD;;AAEDG,EAAAA,IAAI,GAAY;AACd,QAAI,KAAKV,aAAT,EAAwB,MAAM,IAAIF,KAAJ,CAAU,0CAAV,CAAN;AACxB,WAAOa,IAAI,CAACR,KAAL,CAAW,KAAKI,IAAhB,CAAP;AACD;;AArDoC","sourcesContent":["import parseHeader from \"./lib/parseHeader.js\";\nimport parseStatus from \"./lib/parseStatus.js\";\nimport parseText from \"./lib/parseText.js\";\nimport type { Version, HeadersObject } from \"./index.js\";\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error(\"Response missing a content type\");\n    this.contentType = contentType;\n    if (this.contentType === \"application/http\") {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error(\"Attempting to parse a completed response\");\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error(\"Unexpected parsing state\");\n      this.body = this._parsingState.lines.join(\"\\r\\n\");\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, \":\");\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error(\"Attempting to use an incomplete response\");\n    return JSON.parse(this.body);\n  }\n}\n"],"file":"Response.js"}