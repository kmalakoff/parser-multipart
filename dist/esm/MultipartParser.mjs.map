{"version":3,"sources":["MultipartParser.ts"],"sourcesContent":["// @ts-ignore\nimport Part from './PartParser.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: Record<string, string> = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | Record<string, string>) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as Record<string, string>)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): MultipartParser {\n    parseText(this, text);\n    return this;\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n\n  get responses(): Response[] {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete parser');\n    return this.parts.map((part) => part.response);\n  }\n}\n"],"names":["Part","parseHeader","parseText","ParseStatus","Parts","MultipartParser","done","_parsingState","parse","text","push","line","part","parts","length","Error","boundaryEnd","boundary","responses","map","response","constructor","headers","status","contentType","get","split","type","shift","trim","indexOf","forEach"],"mappings":"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"}