{"version":3,"sources":["ResponseParser.ts"],"sourcesContent":["// @ts-ignore\nimport ResponseParsed from './ResponseParsed.ts';\n// @ts-ignore\nimport type { Parser } from './ResponseParsed.ts';\n// @ts-ignore\nimport BodyHeaders from './lib/BodyHeaders.ts';\n// @ts-ignore\nimport parseHeader from './lib/parseHeader.ts';\n// @ts-ignore\nimport parseStatus from './lib/parseStatus.ts';\n// @ts-ignore\nimport parseText from './lib/parseText.ts';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body = 2,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  get response(): Response {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return new ResponseParsed(this as Parser);\n  }\n}\n"],"names":["ResponseParsed","BodyHeaders","parseHeader","parseStatus","parseText","ParseStatus","MultipartResponse","done","_parsingState","parse","text","push","line","Error","status","body","lines","join","length","headers","response","constructor","contentType","undefined"],"mappings":"AAAA,aAAa;;;;;;;;;;;;;;AACb,OAAOA,oBAAoB,sBAAsB;AAGjD,aAAa;AACb,OAAOC,iBAAiB,uBAAuB;AAC/C,aAAa;AACb,OAAOC,iBAAiB,uBAAuB;AAC/C,aAAa;AACb,OAAOC,iBAAiB,uBAAuB;AAC/C,aAAa;AACb,OAAOC,eAAe,qBAAqB;;UAE/BC;;;GAAAA,gBAAAA;AAUG,IAAA,AAAMC,oBAAN,MAAMA;IAmBnBC,OAAgB;QACd,OAAO,CAAC,IAAI,CAACC,aAAa;IAC5B;IAEAC,MAAMC,IAAY,EAAQ;QACxBN,UAAU,IAAI,EAAEM;IAClB;IAEAC,KAAKC,IAAY,EAAQ;QACvB,IAAI,CAAC,IAAI,CAACJ,aAAa,EAAE,MAAM,IAAIK,MAAM;QACzC,IAAID,SAAS,MAAM;YACjB,IAAI,IAAI,CAACJ,aAAa,CAACM,MAAM,QAAuB,MAAM,IAAID,MAAM;YACpE,IAAI,CAACE,IAAI,GAAG,IAAI,CAACP,aAAa,CAACQ,KAAK,CAACC,IAAI,CAAC;YAC1C,IAAI,CAACT,aAAa,GAAG;YACrB;QACF;QAEA,IAAI,IAAI,CAACA,aAAa,CAACM,MAAM,QAA0B;YACrD,IAAI,CAACF,KAAKM,MAAM,EAAE,IAAI,CAACV,aAAa,CAACM,MAAM;iBACtC,IAAI,CAACX,YAAY,IAAI,CAACgB,OAAO,EAAEP,OAAOV,YAAY,IAAI,CAACiB,OAAO,CAACA,OAAO,EAAEP,MAAM;QACrF,OAAO,IAAI,IAAI,CAACJ,aAAa,CAACM,MAAM,QAAuB;YACzD,IAAI,CAACF,KAAKM,MAAM,EAAE,IAAI,CAACP,IAAI,CAAC;iBACvB,IAAI,CAACH,aAAa,CAACQ,KAAK,CAACL,IAAI,CAACC;QACrC;IACF;IAEA,IAAIQ,WAAqB;QACvB,IAAI,IAAI,CAACZ,aAAa,EAAE,MAAM,IAAIK,MAAM;QACxC,OAAO,IAAIb,eAAe,IAAI;IAChC;IAtCAqB,YAAYC,WAAmB,CAAE;QATjCA,uBAAAA,eAAAA,KAAAA;QACAH,uBAAAA,WAAuB;QACvBJ,uBAAAA,QAAe;QAEf,uBAAQP,iBAAqC;YAC3CM,MAAM;YACNE,OAAO,EAAE;QACX;QAGE,IAAIM,gBAAgBC,WAAW,MAAM,IAAIV,MAAM;QAC/C,IAAI,CAACS,WAAW,GAAGA;QACnB,IAAI,IAAI,CAACA,WAAW,KAAK,oBAAoB;YAC3C,IAAI,CAACH,OAAO,GAAG,IAAIlB;YACnB,IAAI,CAACO,aAAa,CAACM,MAAM;QAC3B;IACF;AAgCF;AAjDA,SAAqBR,+BAiDpB"}