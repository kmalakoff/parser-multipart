{"version":3,"sources":["Parser.ts","Response.ts"],"sourcesContent":["import Part from './Part.js';\nimport parseHeader from './lib/parseHeader.js';\nimport parseText from './lib/parseText.js';\nimport type { HeadersObject } from './index.js';\n\nexport enum ParseStatus {\n  Parts = 1,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  boundaryEnd: string | null;\n}\n\nexport default class MultipartParser {\n  type: string;\n  headers: HeadersObject = {};\n  parts: Part[] = [];\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Parts,\n    boundaryEnd: null,\n  };\n  private boundary: string | null = null;\n\n  constructor(headers: Headers | string | HeadersObject) {\n    if (!headers) throw new Error('Headers missing');\n\n    let contentType: string;\n    if (typeof headers === 'string') contentType = headers;\n    /* c8 ignore start */ else if (headers.get) contentType = (headers as Headers).get('content-type');\n    /* c8 ignore stop */ else contentType = (headers as HeadersObject)['content-type'];\n    if (!contentType) throw Error('content-type header not found');\n\n    const parts = contentType.split(/;/g);\n    this.type = parts.shift().trim();\n    if (this.type.indexOf('multipart') !== 0) {\n      throw new Error(`Expecting a multipart type. Received: ${contentType}`);\n    }\n    parts.forEach((part) => parseHeader(this.headers, part, '='));\n\n    // boundary\n    if (!this.headers.boundary) throw new Error('Invalid Content Type: no boundary');\n    this.boundary = `--${this.headers.boundary}`;\n    this._parsingState.boundaryEnd = `--${this.headers.boundary}--`;\n    this._parsingState.status = ParseStatus.Parts;\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    const part = this.parts.length ? this.parts[this.parts.length - 1] : null;\n\n    if (!this._parsingState) throw new Error('Attempting to parse a completed multipart');\n    if (line === null) {\n      if (part && !part.done()) part.push(null);\n      this._parsingState = null;\n      return;\n    }\n\n    if (line === this._parsingState.boundaryEnd) this.push(null);\n    else if (line === this.boundary) {\n      if (part && !part.done()) part.push(null);\n      this.parts.push(new Part());\n    } else if (part) part.push(line);\n    else {\n      if (line.length) throw new Error(`Unexpected line: ${line}`);\n    }\n  }\n}\n","import parseHeader from './lib/parseHeader.js';\nimport parseStatus from './lib/parseStatus.js';\nimport parseText from './lib/parseText.js';\nimport type { Version, HeadersObject } from './index.js';\n\nexport enum ParseStatus {\n  Headers = 1,\n  Body,\n}\n\nexport interface ParsingState {\n  status: ParseStatus;\n  lines: string[];\n}\n\nexport class BodyHeaders {\n  version: Version;\n  headers: HeadersObject = {};\n  ok: boolean;\n  status: number;\n  statusText: string;\n}\n\nexport default class MultipartResponse {\n  contentType: string;\n  headers: BodyHeaders = null;\n  body: string = null;\n\n  private _parsingState: ParsingState | null = {\n    status: ParseStatus.Body,\n    lines: [],\n  };\n\n  constructor(contentType: string) {\n    if (contentType === undefined) throw new Error('Response missing a content type');\n    this.contentType = contentType;\n    if (this.contentType === 'application/http') {\n      this.headers = new BodyHeaders();\n      this._parsingState.status = ParseStatus.Headers;\n    }\n  }\n\n  done(): boolean {\n    return !this._parsingState;\n  }\n\n  parse(text: string): void {\n    parseText(this, text);\n  }\n\n  push(line: string): void {\n    if (!this._parsingState) throw new Error('Attempting to parse a completed response');\n    if (line === null) {\n      if (this._parsingState.status !== ParseStatus.Body) throw new Error('Unexpected parsing state');\n      this.body = this._parsingState.lines.join('\\r\\n');\n      this._parsingState = null;\n      return;\n    }\n\n    if (this._parsingState.status === ParseStatus.Headers) {\n      if (!line.length) this._parsingState.status = ParseStatus.Body;\n      else if (!parseStatus(this.headers, line)) parseHeader(this.headers.headers, line, ':');\n    } else if (this._parsingState.status === ParseStatus.Body) {\n      if (!line.length) this.push(null);\n      else this._parsingState.lines.push(line);\n    }\n  }\n\n  text(): string {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return this.body;\n  }\n\n  json(): unknown {\n    if (this._parsingState) throw new Error('Attempting to use an incomplete response');\n    return JSON.parse(this.body);\n  }\n}\n"],"names":["ParseStatus","Parts","MultipartParser","headers","parts","_parsingState","status","boundaryEnd","boundary","Error","contentType","get","split","type","shift","trim","indexOf","forEach","part","parseHeader","done","parse","text","parseText","push","line","length","Part"],"mappings":"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"}